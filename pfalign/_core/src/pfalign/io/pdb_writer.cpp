/**
 * PDB Writer Implementation
 */

#include "pdb_writer.h"
#include "sequence_utils.h"
#include <fstream>
#include <iomanip>
#include <set>
#include <ctime>

namespace pfalign {
namespace io {

/**
 * Write REMARK records with alignment metrics.
 */
static void write_remarks(std::ofstream& out, const float* rotation, const float* translation,
                          float rmsd, float tm1, float tm2, float gdt_ts, float gdt_ha, int L1,
                          int L2, int N_aligned) {
    // Header
    out << "REMARK   1 STRUCTURAL ALIGNMENT GENERATED BY PROTEIN-FORGE\n";

    std::time_t now = std::time(nullptr);
    char time_buf[64];
    std::strftime(time_buf, sizeof(time_buf), "%Y-%m-%d %H:%M:%S", std::localtime(&now));
    out << "REMARK   1 DATE: " << time_buf << "\n";

    // Metrics
    out << "REMARK   2\n";
    out << "REMARK   2 ALIGNMENT METRICS\n";
    out << "REMARK   2 LENGTH OF STRUCTURE 1: " << L1 << " RESIDUES\n";
    out << "REMARK   2 LENGTH OF STRUCTURE 2: " << L2 << " RESIDUES\n";
    out << "REMARK   2 ALIGNED LENGTH:        " << N_aligned << " RESIDUES\n";
    out << "REMARK   2 RMSD:                  " << std::fixed << std::setprecision(3) << rmsd
        << " ANGSTROM\n";
    out << "REMARK   2 TM-SCORE (NORM BY L1): " << std::fixed << std::setprecision(5) << tm1
        << "\n";
    out << "REMARK   2 TM-SCORE (NORM BY L2): " << std::fixed << std::setprecision(5) << tm2
        << "\n";
    out << "REMARK   2 GDT-TS:                " << std::fixed << std::setprecision(5) << gdt_ts
        << "\n";
    out << "REMARK   2 GDT-HA:                " << std::fixed << std::setprecision(5) << gdt_ha
        << "\n";

    // Rotation matrix
    out << "REMARK   3\n";
    out << "REMARK   3 ROTATION MATRIX (3X3)\n";
    for (int i = 0; i < 3; i++) {
        out << "REMARK   3  " << std::fixed << std::setprecision(6) << std::setw(10)
            << rotation[i * 3 + 0] << " " << std::setw(10) << rotation[i * 3 + 1] << " "
            << std::setw(10) << rotation[i * 3 + 2] << "\n";
    }

    // Translation vector
    out << "REMARK   3\n";
    out << "REMARK   3 TRANSLATION VECTOR (ANGSTROM)\n";
    out << "REMARK   3  " << std::fixed << std::setprecision(6) << std::setw(10) << translation[0]
        << " " << std::setw(10) << translation[1] << " " << std::setw(10) << translation[2] << "\n";

    out << "REMARK   4\n";
    out << "REMARK   4 TRANSFORMATION: COORDS_ALIGNED = R @ COORDS_ORIGINAL + T\n";
    out << "REMARK   5\n";
    out << "REMARK   5 B-FACTOR ENCODING: 1.00 = ALIGNED, 0.00 = GAP\n";
}

/**
 * Write single model to PDB.
 */
static void write_model(std::ofstream& out, int model_num, const Protein& protein,
                        const float* coords, const std::set<int>& aligned_residues,
                        int chain_idx = 0) {
    out << "MODEL     " << std::setw(4) << model_num << "\n";

    const auto& chain = protein.get_chain(chain_idx);
    int atom_serial = 1;

    for (size_t res_idx = 0; res_idx < chain.residues.size(); res_idx++) {
        const auto& residue = chain.residues[res_idx];

        // B-factor: 1.00 if aligned, 0.00 if gap
        float bfactor = aligned_residues.count(static_cast<int>(res_idx)) ? 1.00f : 0.00f;

        // Atom names for backbone: N, CA, C, O
        const char* atom_names[] = {"N", "CA", "C", "O"};

        for (int atom_idx = 0; atom_idx < 4; atom_idx++) {
            float x = coords[static_cast<size_t>((res_idx * 4 + atom_idx) * 3 + 0)];
            float y = coords[static_cast<size_t>((res_idx * 4 + atom_idx) * 3 + 1)];
            float z = coords[static_cast<size_t>((res_idx * 4 + atom_idx) * 3 + 2)];

            // Skip if coordinates are zero (missing atom)
            if (x == 0.0f && y == 0.0f && z == 0.0f)
                continue;

            // ATOM record (PDB format)
            out << "ATOM  " << std::setw(5) << atom_serial << " " << std::setw(4) << std::left
                << atom_names[atom_idx] << std::right << residue.resn << " " << chain.chain_id
                << std::setw(4) << residue.resi << residue.icode << "   " << std::fixed
                << std::setprecision(3) << std::setw(8) << x << std::setw(8) << y << std::setw(8)
                << z << std::setw(6) << std::setprecision(2) << 1.00f  // occupancy
                << std::setw(6) << std::setprecision(2) << bfactor << "           "
                << atom_names[atom_idx][0]  // element symbol
                << "\n";

            atom_serial++;
        }
    }

    out << "ENDMDL\n";
}

/**
 * Write superposed pair to PDB.
 */
bool write_superposed_pair(const std::string& output_path, const Protein& protein1,
                           const float* coords1_aligned, const Protein& protein2,
                           const float* coords2, const float* rotation, const float* translation,
                           float rmsd, float tm_score1, float tm_score2, float gdt_ts, float gdt_ha,
                           const std::vector<std::pair<int, int>>& aligned_pairs) {
    std::ofstream out(output_path);
    if (!out.is_open()) {
        return false;
    }

    int L1 = static_cast<int>(protein1.get_chain(0).size());
    int L2 = static_cast<int>(protein2.get_chain(0).size());

    // Build sets of aligned residues for B-factor coloring
    std::set<int> aligned_res1, aligned_res2;
    for (const auto& [i, j] : aligned_pairs) {
        aligned_res1.insert(i);
        aligned_res2.insert(j);
    }

    // Write header
    out << "HEADER    PROTEIN STRUCTURAL ALIGNMENT\n";

    // Write remarks
    write_remarks(out, rotation, translation, rmsd, tm_score1, tm_score2, gdt_ts, gdt_ha, L1, L2,
                  static_cast<int>(aligned_pairs.size()));

    // Write MODEL 1: aligned protein 1
    write_model(out, 1, protein1, coords1_aligned, aligned_res1);

    // Write MODEL 2: reference protein 2
    write_model(out, 2, protein2, coords2, aligned_res2);

    // End file
    out << "END\n";
    out.close();

    return true;
}

}  // namespace io
}  // namespace pfalign
