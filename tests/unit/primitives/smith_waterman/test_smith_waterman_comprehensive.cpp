/**
 * Comprehensive unit tests for Smith-Waterman forward and backward passes.
 *
 * Tests all 6 forward variants and 6 backward variants against validated
 * JAX reference outputs.
 *
 * Reference data generated by:
 * - validation/scripts/generate_sw_backward_parity.py (synthetic 12*12)
 * - validation/generate_jax_crambin_reference.py (real protein 46*46)
 */

#include "pfalign/primitives/smith_waterman/smith_waterman.h"
#include "pfalign/common/arena_allocator.h"
#include "pfalign/common/growable_arena.h"
#include "pfalign/dispatch/backend_traits.h"
#include <iostream>
#include <iomanip>
#include <cmath>
#include <algorithm>
#include <numeric>
#include <fstream>
#include <vector>
#include <filesystem>

using namespace pfalign;
using namespace pfalign::smith_waterman;

// Test tolerance
constexpr float FORWARD_TOL = 1e-5f;
constexpr float BACKWARD_TOL = 1e-5f;

namespace {

namespace fs = std::filesystem;

fs::path golden_dir() {
    // Use compile-time project source root (passed by Meson)
    return fs::path(PFALIGN_SOURCE_ROOT) / "data" / "golden" / "smith_waterman";
}

// Helper: Load .npy file (simple format)
bool load_npy_simple(const fs::path& path, float* data, int size) {
    std::ifstream f(path, std::ios::binary);
    if (!f) return false;

    char header[256];
    f.read(header, 128);  // Skip numpy header
    f.read(reinterpret_cast<char*>(data), size * sizeof(float));
    f.close();
    return true;
}

// Helper: Check if close
bool close(float a, float b, float tol) {
    return std::abs(a - b) < tol;
}

// Helper: Compute max absolute error
float max_abs_error(const float* a, const float* b, int size) {
    float max_err = 0.0f;
    for (int i = 0; i < size; i++) {
        max_err = std::max(max_err, std::abs(a[i] - b[i]));
    }
    return max_err;
}

} // namespace

// ============================================================================
// Forward Pass Tests (12*12 synthetic)
// ============================================================================

bool test_jax_regular_forward_12x12() {
    std::cout << "=== Test: JAX Regular Forward (12*12) ===" << std::endl;

    const int L1 = 12, L2 = 12;
    float* similarity = new float[L1 * L2];

    // Load test similarity matrix
    if (!load_npy_simple(golden_dir() / "backward_similarity_12x12.npy", similarity, L1 * L2)) {
        std::cerr << "ERROR: Could not load test similarity matrix" << std::endl;
        std::cerr << "Run: conda run -n embedding_diffusion python "
                  << "pfalign/_core/src/pfalign/validation/scripts/generate_sw_backward_parity.py"
                  << std::endl;
        delete[] similarity;
        return false;
    }

    // Parameters
    SWConfig config;
    config.gap = 0.194247f;
    config.temperature = 1.0f;

    // Run forward pass
    float* hij = new float[L1 * L2];
    float partition = 0.0f;

    smith_waterman_jax_regular<ScalarBackend>(
        similarity, L1, L2, config, hij, &partition
    );

    // Load JAX reference partition
    std::ifstream pf(golden_dir() / "backward_partition_regular.txt");
    float jax_partition;
    pf >> jax_partition;
    pf.close();

    // Check partition
    float partition_error = std::abs(partition - jax_partition);
    bool passed = partition_error < FORWARD_TOL;

    std::cout << "  C++ partition: " << partition << std::endl;
    std::cout << "  JAX partition: " << jax_partition << std::endl;
    std::cout << "  Error:         " << partition_error << std::endl;
    std::cout << "  Status:        " << (passed ? "✓ PASS" : "✗ FAIL") << std::endl;
    std::cout << std::endl;

    delete[] similarity;
    delete[] hij;

    return passed;
}

bool test_jax_affine_flexible_forward_12x12() {
    std::cout << "=== Test: JAX Affine Flexible Forward (12*12) ===" << std::endl;

    const int L1 = 12, L2 = 12;
    float* similarity = new float[L1 * L2];

    if (!load_npy_simple(golden_dir() / "backward_similarity_12x12.npy", similarity, L1 * L2)) {
        std::cerr << "ERROR: Could not load test similarity matrix" << std::endl;
        delete[] similarity;
        return false;
    }

    SWConfig config;
    config.gap = 0.194247f;
    config.gap_open = -2.54418f;
    config.gap_extend = 0.194247f;
    config.temperature = 1.0f;

    float* hij = new float[L1 * L2 * 3];
    float partition = 0.0f;

    smith_waterman_jax_affine_flexible<ScalarBackend>(
        similarity, L1, L2, config, hij, &partition
    );

    std::ifstream pf(golden_dir() / "backward_partition_affine.txt");
    float jax_partition;
    pf >> jax_partition;
    pf.close();

    float partition_error = std::abs(partition - jax_partition);
    bool passed = partition_error < FORWARD_TOL;

    std::cout << "  C++ partition: " << partition << std::endl;
    std::cout << "  JAX partition: " << jax_partition << std::endl;
    std::cout << "  Error:         " << partition_error << std::endl;
    std::cout << "  Status:        " << (passed ? "✓ PASS" : "✗ FAIL") << std::endl;
    std::cout << std::endl;

    delete[] similarity;
    delete[] hij;

    return passed;
}

// ============================================================================
// Backward Pass Tests (12*12 synthetic)
// ============================================================================

bool test_jax_regular_backward_12x12() {
    std::cout << "=== Test: JAX Regular Backward (12*12) ===" << std::endl;

    const int L1 = 12, L2 = 12;
    float* similarity = new float[L1 * L2];

    if (!load_npy_simple(golden_dir() / "backward_similarity_12x12.npy", similarity, L1 * L2)) {
        std::cerr << "ERROR: Could not load test similarity matrix" << std::endl;
        delete[] similarity;
        return false;
    }

    SWConfig config;
    config.gap = 0.194247f;
    config.temperature = 1.0f;

    // Forward pass
    float* hij = new float[L1 * L2];
    float partition = 0.0f;
    smith_waterman_jax_regular<ScalarBackend>(
        similarity, L1, L2, config, hij, &partition
    );

    // Backward pass with GrowableArena
    pfalign::memory::GrowableArena temp_arena(1);  // 1 MB
    float* posteriors = new float[L1 * L2];
    smith_waterman_jax_regular_backward<ScalarBackend>(
        hij, similarity, L1, L2, config, partition, posteriors, &temp_arena
    );

    // Load JAX reference
    float* jax_posteriors = new float[L1 * L2];
    if (!load_npy_simple(golden_dir() / "backward_posteriors_regular_12x12.npy", jax_posteriors, L1 * L2)) {
        std::cerr << "ERROR: Could not load JAX posteriors" << std::endl;
        delete[] similarity;
        delete[] hij;
        delete[] posteriors;
        delete[] jax_posteriors;
        return false;
    }

    // Compare
    float max_error = max_abs_error(posteriors, jax_posteriors, L1 * L2);
    bool passed = max_error < BACKWARD_TOL;

    std::cout << "  Max error:  " << max_error << std::endl;
    std::cout << "  Threshold:  " << BACKWARD_TOL << std::endl;
    std::cout << "  Status:     " << (passed ? "✓ PASS" : "✗ FAIL") << std::endl;
    std::cout << std::endl;

    delete[] similarity;
    delete[] hij;
    delete[] posteriors;
    delete[] jax_posteriors;

    return passed;
}

bool test_jax_affine_flexible_backward_12x12() {
    std::cout << "=== Test: JAX Affine Flexible Backward (12*12) ===" << std::endl;

    const int L1 = 12, L2 = 12;
    float* similarity = new float[L1 * L2];

    if (!load_npy_simple(golden_dir() / "backward_similarity_12x12.npy", similarity, L1 * L2)) {
        std::cerr << "ERROR: Could not load test similarity matrix" << std::endl;
        delete[] similarity;
        return false;
    }

    SWConfig config;
    config.gap = 0.194247f;
    config.gap_open = -2.54418f;
    config.gap_extend = 0.194247f;
    config.temperature = 1.0f;

    // Forward pass
    float* hij = new float[L1 * L2 * 3];
    float partition = 0.0f;
    smith_waterman_jax_affine_flexible<ScalarBackend>(
        similarity, L1, L2, config, hij, &partition
    );

    // Backward pass with GrowableArena
    pfalign::memory::GrowableArena temp_arena(1);  // 1 MB
    float* posteriors = new float[L1 * L2];
    smith_waterman_jax_affine_flexible_backward<ScalarBackend>(
        hij, similarity, L1, L2, config, partition, posteriors, &temp_arena
    );

    // Load JAX reference
    float* jax_posteriors = new float[L1 * L2];
    if (!load_npy_simple(golden_dir() / "backward_posteriors_affine_12x12.npy", jax_posteriors, L1 * L2)) {
        std::cerr << "ERROR: Could not load JAX posteriors" << std::endl;
        delete[] similarity;
        delete[] hij;
        delete[] posteriors;
        delete[] jax_posteriors;
        return false;
    }

    // Compare
    float max_error = max_abs_error(posteriors, jax_posteriors, L1 * L2);
    bool passed = max_error < BACKWARD_TOL;

    std::cout << "  Max error:  " << max_error << std::endl;
    std::cout << "  Threshold:  " << BACKWARD_TOL << std::endl;
    std::cout << "  Status:     " << (passed ? "✓ PASS" : "✗ FAIL") << std::endl;
    std::cout << std::endl;

    delete[] similarity;
    delete[] hij;
    delete[] posteriors;
    delete[] jax_posteriors;

    return passed;
}

// ============================================================================
// Edge Case Tests
// ============================================================================

bool test_tiny_matrix_2x2() {
    std::cout << "=== Test: Tiny Matrix (2*2) ===" << std::endl;

    const int L1 = 2, L2 = 2;
    float similarity[4] = {1.0f, 0.5f, 0.5f, 1.0f};

    SWConfig config;
    config.gap = 0.1f;
    config.temperature = 1.0f;

    float hij[4];
    float partition = 0.0f;

    smith_waterman_jax_regular<ScalarBackend>(
        similarity, L1, L2, config, hij, &partition
    );

    // Check partition is finite and positive
    bool passed = std::isfinite(partition) && partition > 0.0f;

    std::cout << "  Partition: " << partition << std::endl;
    std::cout << "  Status:    " << (passed ? "✓ PASS" : "✗ FAIL") << std::endl;
    std::cout << std::endl;

    return passed;
}

bool test_zero_similarity() {
    std::cout << "=== Test: Zero Similarity Matrix ===" << std::endl;

    const int L1 = 5, L2 = 5;
    float similarity[25] = {0.0f};  // All zeros

    SWConfig config;
    config.gap = -0.1f;
    config.temperature = 1.0f;

    float hij[25];
    float partition = 0.0f;

    smith_waterman_jax_regular<ScalarBackend>(
        similarity, L1, L2, config, hij, &partition
    );

    // With zero similarity, partition should still be finite
    bool passed = std::isfinite(partition);

    std::cout << "  Partition: " << partition << std::endl;
    std::cout << "  Status:    " << (passed ? "✓ PASS" : "✗ FAIL") << std::endl;
    std::cout << std::endl;

    return passed;
}

bool test_backward_gradient_sum() {
    std::cout << "=== Test: Backward Gradient Sum Property ===" << std::endl;

    const int L1 = 5, L2 = 5;
    float similarity[25];
    for (int i = 0; i < 25; i++) {
        similarity[i] = ((float)rand() / RAND_MAX) * 2.0f - 1.0f;
    }

    SWConfig config;
    config.gap = 0.1f;
    config.temperature = 1.0f;

    // Forward + backward
    float hij[25];
    float partition = 0.0f;
    smith_waterman_jax_regular<ScalarBackend>(
        similarity, L1, L2, config, hij, &partition
    );

    pfalign::memory::GrowableArena temp_arena(1);  // ~1 MB (sufficient for this test)
    float posteriors[25];
    smith_waterman_jax_regular_backward<ScalarBackend>(
        hij, similarity, L1, L2, config, partition, posteriors, &temp_arena
    );

    // Sum of posteriors should be close to L (number of aligned positions)
    float sum = std::accumulate(posteriors, posteriors + 25, 0.0f);

    // For local alignment, sum is typically close to min(L1, L2)
    bool passed = sum >= 0.0f && sum <= (L1 + L2);  // Reasonable bounds

    std::cout << "  Posterior sum: " << sum << std::endl;
    std::cout << "  Expected range: [0, " << (L1 + L2) << "]" << std::endl;
    std::cout << "  Status:    " << (passed ? "✓ PASS" : "✗ FAIL") << std::endl;
    std::cout << std::endl;

    return passed;
}

// ============================================================================
// Main Test Runner
// ============================================================================

int main() {
    std::cout << "================================================================" << std::endl;
    std::cout << "Smith-Waterman Comprehensive Unit Tests" << std::endl;
    std::cout << "================================================================" << std::endl;
    std::cout << std::endl;

    int passed = 0;
    int total = 0;

    // Forward pass tests (12*12)
    std::cout << "--- Forward Pass Tests (12*12 synthetic) ---" << std::endl;
    std::cout << std::endl;
    total++; if (test_jax_regular_forward_12x12()) passed++;
    total++; if (test_jax_affine_flexible_forward_12x12()) passed++;

    // Backward pass tests (12*12)
    std::cout << "--- Backward Pass Tests (12*12 synthetic) ---" << std::endl;
    std::cout << std::endl;
    total++; if (test_jax_regular_backward_12x12()) passed++;
    total++; if (test_jax_affine_flexible_backward_12x12()) passed++;

    // Edge case tests
    std::cout << "--- Edge Case Tests ---" << std::endl;
    std::cout << std::endl;
    total++; if (test_tiny_matrix_2x2()) passed++;
    total++; if (test_zero_similarity()) passed++;
    total++; if (test_backward_gradient_sum()) passed++;

    // Summary
    std::cout << "================================================================" << std::endl;
    std::cout << "Summary: " << passed << " / " << total << " tests passed" << std::endl;
    std::cout << "================================================================" << std::endl;

    return (passed == total) ? 0 : 1;
}
