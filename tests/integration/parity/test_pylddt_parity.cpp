/**
 * Parity test: Validate C++ LDDT/DALI implementation against pylddt reference.
 *
 * This test loads golden reference data generated by generate_pylddt_parity_data.py
 * and compares C++ implementation results against the Python reference.
 */

#include "pfalign/primitives/structural_metrics/lddt_impl.h"
#include "pfalign/primitives/structural_metrics/dali_impl.h"
#include "pfalign/primitives/structural_metrics/distance_matrix.h"
#include "pfalign/dispatch/scalar_traits.h"
#include <iostream>
#include <fstream>
#include <cmath>
#include <vector>
#include <string>
#include <filesystem>

using namespace pfalign;
using namespace pfalign::structural_metrics;
namespace fs = std::filesystem;

// Simple JSON parser for our reference.json files
struct ReferenceData {
    std::string name;
    std::string description;
    int L;
    float lddt;
    float dali_score;
    float dali_Z;

    static ReferenceData load(const fs::path& json_path) {
        std::ifstream f(json_path);
        if (!f.is_open()) {
            throw std::runtime_error("Failed to open: " + json_path.string());
        }

        ReferenceData data;
        std::string line;
        while (std::getline(f, line)) {
            // Simple string parsing (assumes specific format from our generator)
            if (line.find("\"name\"") != std::string::npos) {
                size_t start = line.find(":") + 3;
                size_t end = line.find("\"", start);
                data.name = line.substr(start, end - start);
            }
            else if (line.find("\"description\"") != std::string::npos) {
                size_t start = line.find(":") + 3;
                size_t end = line.find("\"", start);
                data.description = line.substr(start, end - start);
            }
            else if (line.find("\"L\"") != std::string::npos) {
                size_t start = line.find(":") + 2;
                data.L = std::stoi(line.substr(start));
            }
            else if (line.find("\"lddt\"") != std::string::npos) {
                size_t start = line.find(":") + 2;
                data.lddt = std::stof(line.substr(start));
            }
            else if (line.find("\"dali_score\"") != std::string::npos) {
                size_t start = line.find(":") + 2;
                data.dali_score = std::stof(line.substr(start));
            }
            else if (line.find("\"dali_Z\"") != std::string::npos) {
                size_t start = line.find(":") + 2;
                data.dali_Z = std::stof(line.substr(start));
            }
        }
        return data;
    }
};

// Simple NPY loader for float32 arrays
std::vector<float> load_npy(const fs::path& npy_path, int* rows, int* cols) {
    std::ifstream f(npy_path, std::ios::binary);
    if (!f.is_open()) {
        throw std::runtime_error("Failed to open: " + npy_path.string());
    }

    // Read NPY header (simplified - assumes float32)
    char magic[6];
    f.read(magic, 6);

    uint8_t major, minor;
    f.read(reinterpret_cast<char*>(&major), 1);
    f.read(reinterpret_cast<char*>(&minor), 1);

    uint16_t header_len;
    f.read(reinterpret_cast<char*>(&header_len), 2);

    std::string header(header_len, '\0');
    f.read(&header[0], header_len);

    // Parse shape from header (simplified)
    size_t shape_start = header.find("(");
    size_t shape_end = header.find(")");
    std::string shape_str = header.substr(shape_start + 1, shape_end - shape_start - 1);

    // Parse dimensions
    size_t comma = shape_str.find(",");
    if (comma != std::string::npos) {
        *rows = std::stoi(shape_str.substr(0, comma));
        *cols = std::stoi(shape_str.substr(comma + 1));
    } else {
        *rows = std::stoi(shape_str);
        *cols = 1;
    }

    // Read data
    int total_elements = (*rows) * (*cols);
    std::vector<float> data(total_elements);
    f.read(reinterpret_cast<char*>(data.data()), total_elements * sizeof(float));

    return data;
}

bool test_parity_case(const fs::path& case_dir, float lddt_tolerance = 1e-5f, float dali_tolerance = 1e-2f) {
    std::cout << "\n=== Testing: " << case_dir.filename().string() << " ===\n";

    // Load reference scores
    ReferenceData ref = ReferenceData::load(case_dir / "reference.json");
    std::cout << "  Description: " << ref.description << "\n";
    std::cout << "  Length: " << ref.L << "\n";

    // Load distance matrices
    int L1, L2, L;
    auto dist1 = load_npy(case_dir / "dist1.npy", &L1, &L);
    auto dist2 = load_npy(case_dir / "dist2.npy", &L2, &L);

    if (L1 != ref.L || L2 != ref.L) {
        std::cout << "  ✗ ERROR: Matrix dimensions don't match L\n";
        return false;
    }

    // Build perfect alignment (self-match or same-length comparison)
    std::vector<int> alignment(L1 * 2);
    for (int i = 0; i < L1; i++) {
        alignment[i*2 + 0] = i;
        alignment[i*2 + 1] = i;
    }

    // Test LDDT
    LDDTParams lddt_params;
    float lddt_cpp = lddt_pairwise<ScalarBackend>(
        dist1.data(), dist2.data(),
        alignment.data(), L1,
        lddt_params, nullptr
    );

    float lddt_error = std::abs(lddt_cpp - ref.lddt);
    std::cout << "  LDDT:\n";
    std::cout << "    Reference: " << ref.lddt << "\n";
    std::cout << "    C++:       " << lddt_cpp << "\n";
    std::cout << "    Error:     " << lddt_error << "\n";

    bool lddt_pass = lddt_error < lddt_tolerance;
    if (lddt_pass) {
        std::cout << "    ✓ PASS (error < " << lddt_tolerance << ")\n";
    } else {
        std::cout << "    ✗ FAIL (error >= " << lddt_tolerance << ")\n";
    }

    // Test DALI
    DALIParams dali_params;
    auto dali_result = dali_score<ScalarBackend>(
        dist1.data(), dist2.data(),
        alignment.data(), L1, L1, L1,
        dali_params
    );

    float dali_score_error = std::abs(dali_result.score - ref.dali_score);
    float dali_z_error = std::abs(dali_result.Z - ref.dali_Z);

    std::cout << "  DALI:\n";
    std::cout << "    Reference: score=" << ref.dali_score << ", Z=" << ref.dali_Z << "\n";
    std::cout << "    C++:       score=" << dali_result.score << ", Z=" << dali_result.Z << "\n";
    std::cout << "    Error:     score=" << dali_score_error << ", Z=" << dali_z_error << "\n";

    bool dali_pass = (dali_score_error < dali_tolerance) && (dali_z_error < dali_tolerance);
    if (dali_pass) {
        std::cout << "    ✓ PASS (error < " << dali_tolerance << ")\n";
    } else {
        std::cout << "    ✗ FAIL (error >= " << dali_tolerance << ")\n";
    }

    return lddt_pass && dali_pass;
}

int main() {
    std::cout << "========================================\n";
    std::cout << "  pylddt Parity Tests\n";
    std::cout << "========================================\n";

    // Locate test data directory
    fs::path test_data_dir = "validation/test_data/pylddt_parity";

    // Alternative path if run from build root
    if (!fs::exists(test_data_dir)) {
        test_data_dir = "../validation/test_data/pylddt_parity";
    }

    // Alternative path if run from build/validation
    if (!fs::exists(test_data_dir)) {
        test_data_dir = "test_data/pylddt_parity";
    }

    if (!fs::exists(test_data_dir)) {
        std::cout << "\n⚠ WARNING: Test data not found at: " << fs::absolute(test_data_dir) << "\n";
        std::cout << "Please run generate_pylddt_parity_data.py first:\n";
        std::cout << "  cd validation\n";
        std::cout << "  python3 generate_pylddt_parity_data.py\n\n";
        return 1;
    }

    int passed = 0;
    int total = 0;

    // Test all cases in the parity directory
    std::vector<std::string> test_cases = {
        "self_match_helix",
        "different_folds",
        "similar_helices",
        "translated_helix"
    };

    for (const auto& test_case : test_cases) {
        fs::path case_dir = test_data_dir / test_case;
        if (fs::exists(case_dir)) {
            total++;
            if (test_parity_case(case_dir)) {
                passed++;
            }
        } else {
            std::cout << "\n⚠ WARNING: Test case not found: " << test_case << "\n";
        }
    }

    std::cout << "\n========================================\n";
    std::cout << "Results: " << passed << " / " << total << " tests passed\n";
    std::cout << "========================================\n";

    return (passed == total) ? 0 : 1;
}
